/*
This code creates a particle system where particles move according to a flow field generated by Perlin noise. The particles have properties 
like position, velocity, acceleration, and color, and they follow the flow field, creating visually appealing patterns.
*/

/*
particles: An array to store all the particle objects.
flowField: A 2D array to store the flow vectors.
numParticles: The number of particles in the system.
cols, rows: The number of columns and rows in the flow field.
flowScale: The scale of the flow field, determining the size of each cell in the grid.
hueOffset: A variable to shift the hue of the particles over time.
zoff: A variable to control the third dimension in Perlin noise, allowing the flow field to change over time.

*/



let particles = [];
let flowField = [];
let numParticles = 1000;
let cols, rows;
let flowScale = 20;
let hueOffset = 0;
let zoff = 0;


/*
createCanvas(windowWidth, windowHeight): Creates a canvas that fills the browser window.

pixelDensity(1): Sets the pixel density to 1, ensuring the sketch looks the same on all displays.

colorMode(HSB, 360, 100, 100, 100): Sets the color mode to HSB (Hue, Saturation, Brightness) with a range of 360 for hue and 100 for saturation, brightness, and alpha.

cols = floor(width / flowScale): Calculates the number of columns in the flow field based on the canvas width and flow scale.

rows = floor(height / flowScale): Calculates the number of rows in the flow field based on the canvas height and flow scale.

Initializes the flowField as a 2D array with cols columns and rows rows.

Creates numParticles particles and stores them in the particles array.

Calls updateFlowField to generate the initial flow field.



*/


function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  colorMode(HSB, 360, 100, 100, 100);
  
  cols = floor(width / flowScale);
  rows = floor(height / flowScale);
  
  // Initialize flow field
  for (let i = 0; i < cols; i++) {
    flowField[i] = new Array(rows);
  }
  
  // Create particles
  for (let i = 0; i < numParticles; i++) {
    particles[i] = new Particle();
  }
  
  // Generate initial flow field
  updateFlowField();
}

function draw() {
  background(230, 80, 10, 15);
  
  // Update flow field periodically
  if (frameCount % 30 === 0) {
    updateFlowField();
  }
  
  // Update and display particles
  for (let particle of particles) {
    particle.follow(flowField);
    particle.update();
    particle.display();
  }
  
  // Slowly shift hue over time
  hueOffset += 0.1;
  if (hueOffset > 360) hueOffset -= 360;
  
  // Display FPS
  fill(0, 0, 100);
  text(`FPS: ${floor(frameRate())}`, 10, 20);
}

/*
noiseScale = 0.1: Sets the scale for the Perlin noise function.
noiseSeed(random(10000)): Seeds the noise function with a random value to create different patterns each time. ** Change here
Iterates over each cell in the flow field, calculates a noise-based angle, and creates a vector from that angle.
zoff += 0.01: Increments zoff to change the noise pattern over time.


*/



function updateFlowField() {
  let noiseScale = 0.1;
  noiseSeed(random(10000000));
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let angle = noise(i * noiseScale, j * noiseScale, zoff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowField[i][j] = v;
    }
  }
  
  zoff += 0.01;
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = random(2, 5);
    this.size = random(1, 4);
    this.hue = random(360);
    this.lifespan = 255;
  }
  
  follow(flowField) {
    let x = constrain(floor(this.pos.x / flowScale), 0, cols - 1);
    let y = constrain(floor(this.pos.y / flowScale), 0, rows - 1);
    let force = flowField[x][y].copy();
    force.mult(0.1);
    this.applyForce(force);
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Wrap around edges
    this.pos.x = (this.pos.x + width) % width;
    this.pos.y = (this.pos.y + height) % height;
    
    // Slowly change particle hue and decrease lifespan
    this.hue = (this.hue + 0.2) % 360;
    this.lifespan -= 1;
    
    // Reset particle if lifespan is over
    if (this.lifespan < 0) {
      this.reset();
    }
  }
  
  reset() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.lifespan = 255;
  }
  
  display() {
    noStroke();
    let finalHue = (this.hue + hueOffset) % 360;
    fill(finalHue, 80, 100, this.lifespan);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  cols = floor(width / flowScale);
  rows = floor(height / flowScale);
  updateFlowField();
}